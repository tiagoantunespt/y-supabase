{"version":3,"file":"index.mjs","names":[],"sources":["../src/SupabaseProvider.ts"],"sourcesContent":["import { RealtimeChannel, REALTIME_SUBSCRIBE_STATES } from '@supabase/supabase-js'\nimport type { SupabaseClient } from '@supabase/supabase-js'\nimport * as Y from 'yjs'\nimport {\n  Awareness,\n  applyAwarenessUpdate,\n  encodeAwarenessUpdate,\n  removeAwarenessStates,\n} from 'y-protocols/awareness'\n\ntype SupabaseProviderOptions = {\n  broadcastThrottleMs?: number\n  /** Enable automatic reconnection on disconnect. Default: true */\n  autoReconnect?: boolean\n  /** Maximum reconnection attempts. Default: Infinity */\n  maxReconnectAttempts?: number\n  /** Initial reconnection delay in ms. Default: 1000 */\n  reconnectDelay?: number\n  /** Maximum reconnection delay in ms. Default: 30000 */\n  maxReconnectDelay?: number\n  /** Enable awareness for presence features. Pass true to create new instance, or pass existing Awareness */\n  awareness?: boolean | Awareness\n}\n\ntype Status = 'connecting' | 'connected' | 'disconnected'\n\ntype RealtimeYPayload = {\n  update: string\n  user: {\n    id: string\n  }\n  timestamp: number\n}\n\nconst UPDATE_EVENT = 'y-supabase-update'\nconst STATE_VECTOR_EVENT = 'y-supabase-state-vector'\nconst AWARENESS_EVENT = 'y-supabase-awareness'\n\ntype StateVectorPayload = {\n  stateVector: string\n  user: { id: string }\n  timestamp: number\n}\n\nconst encodeUpdate = (update: Uint8Array) => {\n  let binary = ''\n  const chunkSize = 0x8000\n  for (let i = 0; i < update.length; i += chunkSize) {\n    binary += String.fromCharCode.apply(null, Array.from(update.subarray(i, i + chunkSize)))\n  }\n  return btoa(binary)\n}\n\nconst decodeUpdate = (encoded: string) => {\n  const binary = atob(encoded)\n  const bytes = new Uint8Array(binary.length)\n  for (let i = 0; i < binary.length; i += 1) {\n    bytes[i] = binary.charCodeAt(i)\n  }\n  return bytes\n}\n\ntype ProviderEventMap = {\n  message: (update: Uint8Array) => void\n  awareness: (update: Uint8Array) => void\n  status: (status: Status) => void\n  connect: (provider: SupabaseProvider) => void\n  disconnect: (provider: SupabaseProvider) => void\n  error: (error: Error) => void\n}\n\n/**\n * A Yjs provider that syncs document updates through Supabase Realtime.\n *\n * This provider enables real-time collaboration by broadcasting Yjs document\n * updates to other connected clients via Supabase Realtime channels.\n *\n * @example\n * ```typescript\n * const doc = new Y.Doc()\n * const supabase = createClient(url, key)\n * const provider = new SupabaseProvider('my-room', doc, supabase)\n *\n * provider.on('connect', () => console.log('Connected'))\n * provider.on('message', (update) => console.log('Received update'))\n * ```\n */\nclass SupabaseProvider {\n  private channelName: string\n  private doc: Y.Doc\n  private supabase: SupabaseClient\n  private channel: RealtimeChannel | null = null\n  private status: Status = 'connecting'\n  private userId: string\n  private broadcastTimeout: ReturnType<typeof setTimeout> | null = null\n  private pendingUpdates: Uint8Array[] = []\n  private options: SupabaseProviderOptions | undefined\n  private syncedPeers = new Set<string>()\n  private listeners = new Map<keyof ProviderEventMap, Set<ProviderEventMap[keyof ProviderEventMap]>>()\n  private awareness: Awareness | null = null\n  private reconnectAttempts = 0\n  private reconnectTimeout: ReturnType<typeof setTimeout> | null = null\n  private shouldReconnect = true\n  private boundBeforeUnload: (() => void) | null = null\n\n  constructor(channelName: string, doc: Y.Doc, supabase: SupabaseClient, options?: SupabaseProviderOptions) {\n    this.channelName = channelName\n    this.doc = doc\n    this.supabase = supabase\n    this.options = options\n    this.userId = crypto.randomUUID()\n\n    if (options?.awareness) {\n      this.awareness = options.awareness instanceof Awareness ? options.awareness : new Awareness(doc)\n      this.handleAwarenessUpdate = this.handleAwarenessUpdate.bind(this)\n      this.awareness.on('update', this.handleAwarenessUpdate)\n    }\n\n    this.handleDocUpdate = this.handleDocUpdate.bind(this)\n\n    // Auto-cleanup on page close in browser environments\n    if (typeof window !== 'undefined') {\n      this.boundBeforeUnload = () => this.destroy()\n      window.addEventListener('beforeunload', this.boundBeforeUnload)\n    }\n\n    this.connect()\n  }\n\n  on<K extends keyof ProviderEventMap>(event: K, listener: ProviderEventMap[K]) {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set())\n    }\n    this.listeners.get(event)!.add(listener)\n    return this\n  }\n\n  off<K extends keyof ProviderEventMap>(event: K, listener: ProviderEventMap[K]) {\n    this.listeners.get(event)?.delete(listener)\n    return this\n  }\n\n  private emit<K extends keyof ProviderEventMap>(event: K, ...args: Parameters<ProviderEventMap[K]>) {\n    const eventListeners = this.listeners.get(event)\n    if (eventListeners) {\n      eventListeners.forEach((listener) => {\n        ;(listener as (...args: Parameters<ProviderEventMap[K]>) => void)(...args)\n      })\n    }\n  }\n\n  private setStatus(next: Status) {\n    this.status = next\n    this.emit('status', next)\n  }\n\n  private broadcastUpdate(update: Uint8Array, event = UPDATE_EVENT) {\n    if (!this.channel) return\n\n    const payload: RealtimeYPayload = {\n      update: encodeUpdate(update),\n      user: { id: this.userId },\n      timestamp: Date.now(),\n    }\n\n    this.channel.send({\n      type: 'broadcast',\n      event,\n      payload,\n    })\n  }\n\n  private queueBroadcast(update: Uint8Array) {\n    const throttle = this.options?.broadcastThrottleMs ?? 0\n\n    if (throttle <= 0) {\n      this.broadcastUpdate(update)\n      return\n    }\n\n    this.pendingUpdates.push(update)\n\n    if (this.broadcastTimeout) return\n\n    this.broadcastTimeout = setTimeout(() => {\n      this.broadcastTimeout = null\n      if (this.pendingUpdates.length === 0) return\n\n      const mergedUpdate =\n        this.pendingUpdates.length === 1\n          ? this.pendingUpdates[0]\n          : Y.mergeUpdates(this.pendingUpdates)\n      this.pendingUpdates = []\n      this.broadcastUpdate(mergedUpdate)\n    }, throttle)\n  }\n\n  private handleDocUpdate(update: Uint8Array, origin: unknown) {\n    if (origin === 'remote') return\n\n    this.queueBroadcast(update)\n  }\n\n  private handleRemoteUpdate(payload: RealtimeYPayload) {\n    if (payload.user.id === this.userId) return\n\n    try {\n      const update = decodeUpdate(payload.update)\n      Y.applyUpdate(this.doc, update, 'remote')\n      this.emit('message', update)\n    } catch (err) {\n      this.emit('error', err instanceof Error ? err : new Error('Failed to apply remote update'))\n    }\n  }\n\n  private broadcastAwarenessUpdate(update: Uint8Array) {\n    if (!this.channel) return\n\n    const payload: RealtimeYPayload = {\n      update: encodeUpdate(update),\n      user: { id: this.userId },\n      timestamp: Date.now(),\n    }\n\n    this.channel.send({\n      type: 'broadcast',\n      event: AWARENESS_EVENT,\n      payload,\n    })\n  }\n\n  private handleAwarenessUpdate(\n    { added, updated, removed }: { added: number[]; updated: number[]; removed: number[] },\n    origin: 'remote' | Awareness | null\n  ) {\n    if (!this.awareness) return\n    if (origin === 'remote') return\n\n    const update = encodeAwarenessUpdate(this.awareness, [...added, ...updated, ...removed])\n    this.broadcastAwarenessUpdate(update)\n  }\n\n  private handleRemoteAwareness(payload: RealtimeYPayload) {\n    if (!this.awareness) return\n    if (payload.user.id === this.userId) return\n\n    try {\n      const update = decodeUpdate(payload.update)\n      applyAwarenessUpdate(this.awareness, update, 'remote')\n      this.emit('awareness', update)\n    } catch (err) {\n      this.emit('error', err instanceof Error ? err : new Error('Failed to apply awareness update'))\n    }\n  }\n\n  /**\n   * Sends our state vector to request missing updates from peers.\n   */\n  private sendStateVector() {\n    if (!this.channel) return\n\n    const stateVector = Y.encodeStateVector(this.doc)\n    const payload: StateVectorPayload = {\n      stateVector: encodeUpdate(stateVector),\n      user: { id: this.userId },\n      timestamp: Date.now(),\n    }\n\n    this.channel.send({\n      type: 'broadcast',\n      event: STATE_VECTOR_EVENT,\n      payload,\n    })\n  }\n\n  /**\n   * Handles incoming state vector from a peer.\n   * Computes the diff (what the peer is missing) and sends it.\n   */\n  private handleStateVector(payload: StateVectorPayload) {\n    if (payload.user.id === this.userId) return\n\n    // Prevent infinite ping-pong - only sync once per peer\n    if (this.syncedPeers.has(payload.user.id)) return\n    this.syncedPeers.add(payload.user.id)\n\n    try {\n      const remoteStateVector = decodeUpdate(payload.stateVector)\n\n      // Compute what the remote peer is missing based on their state vector\n      const diff = Y.encodeStateAsUpdate(this.doc, remoteStateVector)\n\n      // Only send if there's actual data (empty update is ~2 bytes)\n      if (diff.length > 2) {\n        this.broadcastUpdate(diff)\n      }\n\n      // Send our state vector so they can send us what we're missing\n      this.sendStateVector()\n    } catch (err) {\n      this.emit('error', err instanceof Error ? err : new Error('Failed to handle state vector'))\n    }\n  }\n\n  /**\n   * Connects to the Supabase Realtime channel and starts syncing.\n   * Called automatically in the constructor. Can be called again to reconnect.\n   */\n  connect() {\n    this.shouldReconnect = true\n    this.doc.off('update', this.handleDocUpdate)\n    this.doc.on('update', this.handleDocUpdate)\n    this.syncedPeers.clear()\n\n    this.channel = this.supabase.channel(this.channelName)\n\n    this.channel\n      .on('broadcast', { event: STATE_VECTOR_EVENT }, (data: { payload: StateVectorPayload }) => {\n        this.handleStateVector(data.payload)\n      })\n      .on('broadcast', { event: UPDATE_EVENT }, (data: { payload: RealtimeYPayload }) => {\n        this.handleRemoteUpdate(data.payload)\n      })\n      .on('broadcast', { event: AWARENESS_EVENT }, (data: { payload: RealtimeYPayload }) => {\n        this.handleRemoteAwareness(data.payload)\n      })\n      .subscribe((status, err) => {\n        if (status === REALTIME_SUBSCRIBE_STATES.SUBSCRIBED) {\n          this.setStatus('connected')\n          this.emit('connect', this)\n          this.reconnectAttempts = 0 // Reset reconnect attempts on successful connection\n\n          // Broadcast initial awareness state to existing peers\n          if (this.awareness) {\n            const update = encodeAwarenessUpdate(\n              this.awareness,\n              Array.from(this.awareness.getStates().keys())\n            )\n            this.broadcastAwarenessUpdate(update)\n          }\n\n          // Send our state vector to request sync from existing peers\n          this.sendStateVector()\n        } else if (status === REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR) {\n          this.setStatus('disconnected')\n          this.emit('error', err ?? new Error('Channel error'))\n          this.emit('disconnect', this)\n          this.scheduleReconnect()\n        } else if (status === REALTIME_SUBSCRIBE_STATES.TIMED_OUT) {\n          this.setStatus('disconnected')\n          this.emit('error', new Error('Connection timed out'))\n          this.emit('disconnect', this)\n          this.scheduleReconnect()\n        } else if (status === REALTIME_SUBSCRIBE_STATES.CLOSED) {\n          this.setStatus('disconnected')\n          this.emit('disconnect', this)\n          this.scheduleReconnect()\n        }\n      })\n  }\n\n  /**\n   * Schedule a reconnection attempt with exponential backoff.\n   */\n  private scheduleReconnect() {\n    const autoReconnect = this.options?.autoReconnect ?? true\n    const maxAttempts = this.options?.maxReconnectAttempts ?? Infinity\n\n    if (!autoReconnect || !this.shouldReconnect || this.reconnectAttempts >= maxAttempts) {\n      return\n    }\n\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout)\n      this.reconnectTimeout = null\n    }\n\n    const baseDelay = this.options?.reconnectDelay ?? 1000\n    const maxDelay = this.options?.maxReconnectDelay ?? 30000\n\n    // Exponential backoff: 1s, 2s, 4s, 8s\n    const delay = Math.min(baseDelay * Math.pow(2, this.reconnectAttempts), maxDelay)\n\n    this.reconnectAttempts++\n\n    this.reconnectTimeout = setTimeout(() => {\n      if (this.shouldReconnect) {\n        this.connect()\n      }\n    }, delay)\n  }\n\n  /**\n   * Disconnects from the channel and cleans up all resources.\n   * Call this when the provider is no longer needed to prevent memory leaks.\n   */\n  destroy() {\n    this.shouldReconnect = false\n\n    if (this.broadcastTimeout) {\n      clearTimeout(this.broadcastTimeout)\n      this.broadcastTimeout = null\n    }\n\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout)\n      this.reconnectTimeout = null\n    }\n\n    if (this.boundBeforeUnload && typeof window !== 'undefined') {\n      window.removeEventListener('beforeunload', this.boundBeforeUnload)\n      this.boundBeforeUnload = null\n    }\n\n    this.doc.off('update', this.handleDocUpdate)\n\n    if (this.awareness) {\n      removeAwarenessStates(this.awareness, [this.doc.clientID], 'local')\n      this.awareness.off('update', this.handleAwarenessUpdate)\n    }\n\n    if (this.channel) {\n      this.supabase.removeChannel(this.channel)\n      this.channel = null\n    }\n  }\n\n  /**\n   * Returns the current connection status.\n   * @returns The current status: 'connecting', 'connected', or 'disconnected'\n   */\n  getStatus() {\n    return this.status\n  }\n\n  /**\n   * Returns the Awareness instance if awareness was enabled.\n   * @returns The Awareness instance or null if awareness is disabled\n   */\n  getAwareness() {\n    return this.awareness\n  }\n}\n\nexport type { SupabaseProviderOptions }\nexport { SupabaseProvider }\n"],"mappings":"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"}